<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Android编译时注解框架-什么是编译时注解</title>

</head>
<body>
<h2>Android编译时注解框架-什么是编译时注解</h2>

<p><br/><br/></p>

<p>《Android编译时注解框架-什么是编译时注解》</p>

<p>《Android编译时注解框架-Run Demo》</p>

<p>《Android编译时注解框架-爬坑》</p>

<p>《Android编译时注解框架-语法讲解》</p>

<p>《Android编译时注解框架-APP更新回滚框架CakeRun》</p>

<p>《Android编译时注解框架-数据库ORM框架CakeORM》</p>

<p>《Android编译时注解框架-事件分发框架CakeBus》</p>

<p>《Android编译时注解框架-View绑定框架CakeKnife》</p>

<hr />

<h3>1.概述</h3>

<p>提到注解，普遍都会有两种态度：黑科技、低性能。使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如DataBinding、ButterKnife、Retrofit。但运行时注解会因为java反射而引起一些性能问题。</p>

<p>而今天我们要讲的就是，不会对性能有任何影响的黑科技：<strong>编译时注解</strong>。通常也叫它：<strong>代码生成</strong>。在编译时对注解做处理，生成代码，运行时和直接运行代码没有任何区别。</p>

<p>得当的使用编译时注解，可以极大的提高开发效率，避免编写重复代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。</p>

<p>本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。</p>

<ul>
<li><p>什么是注解</p></li>
<li><p>运行时注解的简单实用</p></li>
<li><p>编译时注解框架ButterKnife源码初探</p></li>
</ul>


<h3>2.什么是注解</h3>

<p>注解你一定不会陌生，这就是我们最常见的注解：</p>

<p><img src="./1.jpeg" alt="" /></p>

<p>如果你对注解有过些微研究的话，你应该知道注解分为三类，：</p>

<ul>
<li><p>标准 Annotation</p>

<p>  包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们是由编译器来识别的，不会进行编译，对代码运行不会造成任何影响，至于他们的含义不是这篇博客的重点，不再讲述。</p></li>
<li><p>元 Annotation</p>

<p>  @Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们需要自定义注解时，需要通过他们来实现。</p></li>
<li><p>自定义 Annotation</p>

<p>  根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。</p></li>
</ul>


<p>你知道了可以自定义Annotation后，就应该知道，自定义的Annotation同样分为三类。都通过元Annotation - @Retention 定义：</p>

<ul>
<li><p>@Retention(RetentionPolicy.SOURCE)</p>

<p>  源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）</p></li>
<li><p>@Retention(RetentionPolicy.RUNTIME)</p>

<p>  运行时注解，一般在运行时通过反射去识别的注解。</p></li>
<li><p>@Retention(RetentionPolicy.CLASS)</p>

<p>  编译时注解，这是我们重点要讲的。在编译时被识别并处理的注解。</p></li>
</ul>


<p>我们主要讲的就是编译时注解，俗称代码生成。技术实现依赖是<strong>APT(Annotation Processing Tool) </strong>。</p>

<h3>3.运行时注解的简单实用</h3>

<p>运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。</p>

<p>下面展示一个Demo。其功能是通过注解实现布局文件的设置。</p>

<p>比如之前我们是这样设置布局文件的：</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_home);
}
</code></pre>

<p>如果使用注解，我们就可以这样设置布局了</p>

<pre><code>@ContentView(R.layout.activity_home)
public class HomeActivity extends BaseActivity {
    。。。
}
</code></pre>

<p>我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。</p>

<p>那么这样的注解是怎么实现的呢？很简单，往下看。</p>

<h5>3.1创建一个注解</h5>

<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface ContentView {
    int value();
}
</code></pre>

<p><strong>第一行:@Retention(RetentionPolicy.RUNTIME)</strong></p>

<p>@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。</p>

<p><strong>第二行：@Target({ElementType.TYPE})</strong></p>

<p>@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。</p>

<p><strong>第三行：public @interface ContentView</strong></p>

<p>这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。</p>

<p><strong>第四行：int value();</strong></p>

<p>返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的</p>

<pre><code>@ContentView(R.layout.activity_home)
</code></pre>

<p>R.layout.activity_home实质是一个int型id，如果这样用就会报错：</p>

<pre><code>@ContentView(“string”)
</code></pre>

<p><strong>关于注解的详细语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中</strong></p>

<h5>3.2 注解解析</h5>

<p>注解申明好了，但具体是怎么识别这个注解并使用的呢？</p>

<pre><code>@ContentView(R.layout.activity_home)
public class HomeActivity extends BaseActivity {
    。。。
}
</code></pre>

<p>注解的解析就在BaseActivity中。我们看一下BaseActivity代码</p>

<pre><code>public class BaseActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //注解解析
    for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {
        ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);
        if (annotation != null) {
            try {
                this.setContentView(annotation.value());
            } catch (RuntimeException e) {
                e.printStackTrace();
            }
            return;
        }
    }
}
</code></pre>

<p>第一步：遍历所有的子类</p>

<p>第二步：找到修饰了注解ContentView的类</p>

<p>第三步：获取ContentView的属性值。</p>

<p>第四步：为Activity设置布局。</p>

<h5>3.3 总结</h5>

<p>看完这个，相信你对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方放在哪了。</p>

<p>你可能会觉得<em>setContentView(R.layout.activity_home)</em>和<em>@ContentView(R.layout.activity_home)</em>没什么区别，用了注解反而还增加了性能问题。</p>

<p>但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。</p>

<p>因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我学长写得。</p>

<h3>4.编译时注解框架ButterKnife源码初探</h3>

<p>ButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：</p>

<p><img src="./2.jpeg" alt="" /></p>

<p>你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。</p>

<p>秘密在这里，编译工程后，打开你的项目下app目录下的build目录：</p>

<p><img src="./3.jpeg" alt="" /></p>

<p>你可以看到一些带有<em>$$ViewBinder</em>后缀的类文件。这个就是ButterKnife生成的代码我们打开它：</p>

<p><img src="./5.jpeg" alt="" /></p>

<p>上面有一条注释：
// Generated code from Butter Knife. Do not modify!</p>

<p>1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：</p>

<pre><code>package com.zhaoxuan.wehome.view.activity;
</code></pre>

<p>同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：</p>

<pre><code>    //accountEdit是ForgetActivity当中定义的控件
    target.accountEdit = finder.castView(view, 2131558541, "field 'accountEdit'");
</code></pre>

<p>2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。</p>

<pre><code>@Override
public void bind(final Finder finder, final T target, Object source) {
    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）
    View view;

    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。
    view = finder.findRequiredView(source, 2131558541, "field 'accountEdit'");

    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值
    target.accountEdit = finder.castView(view, 2131558541, "field 'accountEdit'");

    view = finder.findRequiredView(source, 2131558543, "field 'forgetBtn' and method 'forgetOnClick'");
    target.forgetBtn = finder.castView(view, 2131558543, "field 'forgetBtn'");

    //给view设置一个点击事件
    view.setOnClickListener(
            new butterknife.internal.DebouncingOnClickListener() {
                @Override
                public void doClick(android.view.View p0) {

                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。
                   target.forgetOnClick();

                }
            });
}
</code></pre>

<p>OK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：</p>

<p>1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。</p>

<p>2.Finder到底是个什么东西？凭什么它可以找到view。</p>

<p>不着急不着急，慢慢看。</p>

<h5>4.1 注解: @Bind的定义</h5>

<p><img src="./6.jpeg" alt="" /></p>

<p>我们可以解读的信息如下：</p>

<p>1.Bind是编译时注解</p>

<p>2.只能修饰属性</p>

<p>3.属性值是一个int型的数组。</p>

<p>创建好自定义注解以后，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。</p>

<h5>4.2 Finder类</h5>

<p>通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。</p>

<p><img src="./8.jpeg" alt="" /></p>

<p>根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。</p>

<p>另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： <em>finder.findRequiredView</em> 和 <em>finder.castView</em></p>

<p><img src="./9.jpeg" alt="" /></p>

<p>findRequiredView 方法调用了 findOptionalView 方法</p>

<p>findOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）</p>

<p>findView取得view后，又交给了castView做一些容错处理。</p>

<p>castView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。</p>

<h5>4.3 ButterKnife.bind(this)方法</h5>

<p><em>ButterKnife.bind(this)</em>这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~</p>

<p>bind有几个重载方法，但最终调的都是下面这个方法。</p>

<p><img src="./7.jpeg" alt="" /></p>

<p>参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。</p>

<p>首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：<em>ForgetActivity$$ViewBinder</em>。</p>

<p>然后调用ForgetActivity$$ViewBinder的bind方法。</p>

<p>然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。</p>

<h5>4.4 ButterKnifeProcessor</h5>

<p>你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。</p>

<p><img src="./10.jpeg" alt="" /></p>

<p>AbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。</p>

<p><img src="./11.jpeg" alt="" /></p>

<p>重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。</p>

<p>第一个最明显的就是Bind注解啦。</p>

<p>而所有的注解处理，都是在process中执行的：</p>

<p><img src="./12.jpeg" alt="" /></p>

<p>通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。</p>

<p>JavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。</p>

<p>这里我们只关注最重要的一句话</p>

<pre><code>writer.write(bindingClass.brewJava());
</code></pre>

<p>ForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。</p>

<h5>4.5 bindingClass.brewJava方法</h5>

<p>哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……</p>

<p>我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……</p>

<p>既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。</p>

<p>由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~</p>

<p><img src="./13.jpeg" alt="" /></p>

<h3>总结</h3>

<p>当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。</p>

<p>但这不正是学习的魅力么？</p>

<p>好了，总结一下。</p>

<p>1.编译时注解的魅力在于：编译时按照一定侧率生成代码，避免编写重复代码，提高开发效率，且不影响性能。</p>

<p>2.代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。</p>

<p>3.APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~</p>

<p>4.ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：<strong>写一个框架最难的不是技术实现，而是稳定！</strong></p>

<p>APT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。</p>

<p>后续篇章我将会陆续推出几款以Cake命名的APT框架。</p>
</body>
</html>